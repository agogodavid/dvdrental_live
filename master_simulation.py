#!/usr/bin/env python3
"""
Master Simulation Script - Generate realistic DVD rental database

This script orchestrates the full simulation pipeline:
1. Initial database setup with starter inventory
2. Periodic inventory additions
3. Regular weekly incremental updates
4. Seasonal demand variations (summer boost, holiday season, etc.)
5. Progress tracking and statistics

Configuration can be easily modified by adjusting the values in config.json.
"""

import mysql.connector
from mysql.connector import Error
import json
import logging
import sys
from datetime import datetime, timedelta, date
from typing import Dict, List, Tuple

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ============================================================================
# SIMULATION CONFIGURATION - LOADED FROM config.json
# ============================================================================

class SimulationConfig:
    """Configuration for the master simulation"""
    
    # Timeline - Loaded from config.json
    START_DATE = None
    TOTAL_WEEKS = None
    
    # Inventory Management
    # Format: (week_number, quantity, description)
    # First entry at week 0 is initial creation
    # NOTE: Inventory schedule is now dynamically generated by inventory_scheduler.py
    
    # Film Releases (adds new films to catalog)
    # Format: (week_number, num_films, category_focus, description)
    FILM_RELEASES = [
        (0, 0, None, "Initial catalog loaded by generator"),
        (8, 3, "Action", "Q4 2001 - Action blockbusters"),
        (16, 3, "Comedy", "Q1 2002 - Comedy releases"),
        (26, 4, "Drama", "Q2 2002 - Award-worthy dramas"),
        (36, 3, "Horror", "Q3 2002 - Summer scares"),
        (48, 4, "Romance", "Q4 2002 - Holiday romances"),
        (60, 3, "Sci-Fi", "Q1 2003 - Sci-Fi adventures"),
        (72, 3, "Animation", "Q2 2003 - Animated features"),
        (84, 4, "Action", "Q3 2003 - Summer action"),
        (100, 3, "Family", "Q4 2003 - Holiday family films"),
        # Uncomment and extend for 10+ year simulation:
        # (112, 3, "Thriller", "Q1 2004 - Thriller releases"),
        # (124, 3, "Comedy", "Q2 2004 - Comedy hits"),
    ]
    
    # Seasonal demand multipliers by month
    # 1=January, 12=December
    SEASONAL_MULTIPLIERS = {
        1: 20,    # January: Cold months, slight boost
        2: -10,   # February: Post-holiday slump
        3: 10,    # March: Spring approaching
        4: 15,    # April: Spring refresh
        5: 20,    # May: Pre-summer boost
        6: 80,    # June: Summer begins! Major boost
        7: 100,   # July: Peak summer season
        8: 90,    # August: Late summer
        9: 30,    # September: Back to school
        10: 25,   # October: Fall season
        11: 40,   # November: Thanksgiving prep
        12: 60,   # December: Holiday rush
    }


def load_config(config_file='config.json', override_database=None) -> dict:
    """Load MySQL configuration
    
    Args:
        config_file: Path to config.json file
        override_database: Optional database name to override config.json setting
    
    Returns:
        Configuration dict with optional database override applied
    """
    with open(config_file, 'r') as f:
        config = json.load(f)
    
    # Override database name if provided
    if override_database:
        config['mysql']['database'] = override_database
        logger.info(f"Using database: {override_database} (overriding config.json)")
    
    return config


def get_seasonal_drift(date: datetime.date) -> float:
    """Get seasonal demand multiplier for given date"""
    month = date.month
    return SimulationConfig.SEASONAL_MULTIPLIERS.get(month, 0)


def week_number_for_date(date: datetime.date, start_date: datetime.date) -> int:
    """Calculate week number since start date"""
    return (date - start_date).days // 7


def create_database_if_needed(mysql_config: dict) -> bool:
    """
    Create the database if it doesn't exist
    
    Returns:
        True if database created or already exists, False on error
    """
    try:
        # Connect to MySQL without specifying database
        conn = mysql.connector.connect(
            host=mysql_config['host'],
            user=mysql_config['user'],
            password=mysql_config['password']
        )
        cursor = conn.cursor()
        
        db_name = mysql_config['database']
        
        # Check if database exists
        cursor.execute("SHOW DATABASES LIKE %s", (db_name,))
        exists = cursor.fetchone() is not None
        
        if not exists:
            logger.info(f"Creating database '{db_name}'...")
            cursor.execute(f"CREATE DATABASE `{db_name}` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci")
            logger.info(f"‚úì Database '{db_name}' created successfully")
        else:
            logger.info(f"Database '{db_name}' already exists, using existing database")
        
        cursor.close()
        conn.close()
        return True
        
    except Error as e:
        logger.error(f"Error creating database: {e}")
        return False


def run_initial_setup(mysql_config: dict) -> Tuple[int, int]:
    """
    Run initial database setup using generator.py
    Returns: (initial_weeks, initial_inventory_count)
    """
    logger.info("=" * 80)
    logger.info("PHASE 1: Initial Database Setup")
    logger.info("=" * 80)
    
    try:
        from generator import DVDRentalDataGenerator
        
        generator = DVDRentalDataGenerator(mysql_config)
        generator.connect()
        
        logger.info(f"Initializing database for start date: {SimulationConfig.START_DATE}")
        generator.initialize_and_seed()
        
        # Get inventory count after initial setup
        generator.cursor.execute("SELECT COUNT(*) FROM inventory")
        initial_inventory = generator.cursor.fetchone()[0]
        logger.info(f"‚úì Initial inventory created: {initial_inventory} items")
        
        # Generate initial rental transactions (~12 weeks)
        logger.info("Generating initial rental transactions...")
        initial_weeks = 12
        generator.generate_weeks(initial_weeks, start_date=SimulationConfig.START_DATE)
        
        # Count initial transactions
        generator.cursor.execute("SELECT COUNT(*) FROM rental")
        initial_rentals = generator.cursor.fetchone()[0]
        logger.info(f"‚úì Initial transactions created: {initial_rentals} rentals over {initial_weeks} weeks")
        
        generator.disconnect()
        
        return initial_weeks, initial_inventory
        
    except Exception as e:
        logger.error(f"Failed to run initial setup: {e}")
        raise


def get_monday_of_latest_rental_week(mysql_config: dict) -> date:
    """Get the Monday of the week containing the most recent rental"""
    try:
        conn = mysql.connector.connect(
            host=mysql_config['host'],
            user=mysql_config['user'],
            password=mysql_config['password'],
            database=mysql_config['database']
        )
        cursor = conn.cursor()
        
        # Get most recent rental date
        cursor.execute("SELECT MAX(rental_date) FROM rental")
        result = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if result and result[0]:
            latest_rental = result[0]
            if isinstance(latest_rental, datetime):
                latest_rental_date = latest_rental.date()
            else:
                latest_rental_date = latest_rental
            
            # Get Monday of that week (0=Monday, 6=Sunday)
            monday_of_week = latest_rental_date - timedelta(days=latest_rental_date.weekday())
            return monday_of_week
    except Exception as e:
        logger.warning(f"Could not get latest rental date: {e}")
    
    # Fallback to today if no rentals exist
    return date.today() - timedelta(days=date.today().weekday())


def add_inventory_batch(mysql_config: dict, quantity: int, description: str, date_purchased=None, staff_id=None) -> int:
    """Add inventory using inventory_manager logic and track purchases"""
    try:
        import random
        from datetime import date as date_class
        
        conn = mysql.connector.connect(
            host=mysql_config['host'],
            user=mysql_config['user'],
            password=mysql_config['password'],
            database=mysql_config['database']
        )
        cursor = conn.cursor()
        
        # Use provided date or today's date
        if date_purchased is None:
            date_purchased = date_class.today()
        
        # Get all films and stores
        cursor.execute("SELECT DISTINCT film_id FROM film")
        film_ids = [row[0] for row in cursor.fetchall()]
        
        cursor.execute("SELECT DISTINCT store_id FROM store")
        store_ids = [row[0] for row in cursor.fetchall()]
        
        # Get staff if not provided
        if staff_id is None:
            cursor.execute("SELECT DISTINCT staff_id FROM staff WHERE active = TRUE")
            staff_ids = [row[0] for row in cursor.fetchall()]
            if not staff_ids:
                cursor.execute("SELECT DISTINCT staff_id FROM staff LIMIT 1")
                staff_row = cursor.fetchone()
                if staff_row:
                    staff_ids = [staff_row[0]]
                else:
                    logger.warning("No staff members found, cannot add inventory")
                    cursor.close()
                    conn.close()
                    return 0
        else:
            staff_ids = [staff_id]
        
        if not film_ids or not store_ids:
            logger.warning("No films or stores found")
            cursor.close()
            conn.close()
            return 0
        
        # Create inventory items with new columns
        inventory = []
        for _ in range(quantity):
            film_id = random.choice(film_ids)
            store_id = random.choice(store_ids)
            assigned_staff_id = random.choice(staff_ids) if len(staff_ids) > 1 else staff_ids[0]
            inventory.append((film_id, store_id, date_purchased, assigned_staff_id))
        
        cursor.executemany(
            "INSERT INTO inventory (film_id, store_id, date_purchased, staff_id) VALUES (%s, %s, %s, %s)",
            inventory
        )
        conn.commit()
        
        # Track inventory purchases (link to staff for subsequent waves)
        cursor.execute("SELECT LAST_INSERT_ID()")
        first_inventory_id = cursor.fetchone()[0]
        
        # Record inventory purchases
        purchase_records = []
        for i in range(len(inventory)):
            inventory_id = first_inventory_id + i
            # For periodic inventory additions, link to staff member
            staff_id = inventory[i][3] if inventory[i][3] else None
            film_id = inventory[i][0]
            purchase_records.append((film_id, inventory_id, staff_id, date_purchased))
        
        # Create inventory_purchases table if it doesn't exist
        create_purchases_table_query = """
        CREATE TABLE IF NOT EXISTS inventory_purchases (
            purchase_id INT AUTO_INCREMENT PRIMARY KEY,
            film_id INT NOT NULL,
            inventory_id INT,
            staff_id INT,
            purchase_date DATE NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (film_id) REFERENCES film(film_id),
            FOREIGN KEY (inventory_id) REFERENCES inventory(inventory_id),
            FOREIGN KEY (staff_id) REFERENCES staff(staff_id),
            INDEX idx_film_id (film_id),
            INDEX idx_staff_id (staff_id),
            INDEX idx_purchase_date (purchase_date)
        ) ENGINE=InnoDB
        """
        cursor.execute(create_purchases_table_query)
        
        cursor.executemany("""
            INSERT INTO inventory_purchases (film_id, inventory_id, staff_id, purchase_date)
            VALUES (%s, %s, %s, %s)
        """, purchase_records)
        conn.commit()
        
        logger.info(f"‚úì Added {quantity} inventory items - {description}")
        
        cursor.close()
        conn.close()
        return len(inventory)
        
    except Exception as e:
        logger.error(f"Failed to add inventory: {e}")
        return 0


# ============================================================================
# FILM GENERATION SYSTEM - Generate realistic film titles by category
# ============================================================================

FILM_TEMPLATES = {
    "Action": {
        "titles": [
            "The {adjective} Agent", "Mission: {location}", "Operation {name}",
            "Escape from {location}", "The {adjective} Warrior", "Hunt for {name}",
            "Raid on {location}", "The {adjective} Soldier", "Assault {location}",
            "The {adjective} Commando", "Strike Force {name}", "Combat {location}",
            "Siege of {location}", "The {adjective} Pursuit", "Midnight {name}",
            "The Last {name}", "Maximum {adjective}", "Extreme {name}",
            "The {adjective} Siege", "Operation Exodus", "The Final {name}"
        ],
        "adjectives": ["Last", "Final", "Ultimate", "Greatest", "Deadliest", "Fastest", "Bravest", "Wildest"],
        "locations": ["Tokyo", "Berlin", "Moscow", "Bangkok", "Istanbul", "Cairo", "Rio", "Vegas"],
        "names": ["Vendetta", "Retribution", "Reckoning", "Justice", "Thunder", "Inferno", "Phoenix", "Reborn"],
        "descriptions": [
            "An elite agent must stop a dangerous criminal mastermind",
            "A former soldier returns for one final mission",
            "Special forces mount a desperate rescue operation",
            "A lone warrior battles an international conspiracy",
            "A skilled operative infiltrates enemy territory"
        ],
        "rating_dist": [("PG-13", 0.4), ("R", 0.6)],
        "length_range": (90, 130),
        "cost_range": (15, 25)
    },
    
    "Comedy": {
        "titles": [
            "The {adjective} {noun}", "{adjective} Love", "Mr. {name}",
            "Crazy {name}", "The {adjective} Plan", "Love at {location}",
            "Office {adjective}", "The {name} Chronicles", "{name} Goes {location}",
            "Mistaken {noun}", "The {adjective} Wedding", "Speed {noun}",
            "Four {adjective} Friends", "The {location} {noun}", "A {adjective} Affair",
            "Little {name}", "Big {name}", "Zany {noun}", "{adjective} Business"
        ],
        "adjectives": ["Crazy", "Silly", "Angry","Hilarious", "Funny", "Awkward", "Wild", "Stupid", "Mad", "Bizarre"],
        "nouns": ["Dating", "Dates", "Weddings", "Vacation", "Holidays", "Office", "School", "Family"],
        "locations": ["in Paris", "in New York", "in Vegas", "in LA", "Down Under", "in Lagos","in Nairobi"],
        "names": ["Marco", "Lucy", "Sophie", "Charlie", "Sam", "Alex"],
        "descriptions": [
            "A bumbling hero stumbles through misadventures",
            "Three friends try to navigate modern romance",
            "An ordinary person finds themselves in extraordinary situations",
            "A workplace comedy with hilarious mishaps",
            "Friends reunite for a disastrous vacation"
        ],
        "rating_dist": [("G", 0.1), ("PG", 0.3), ("PG-13", 0.4), ("R", 0.2)],
        "length_range": (85, 110),
        "cost_range": (14, 20)
    },
    
    "Drama": {
        "titles": [
            "The {noun} of {name}", "When {name} {verb}", "A {adjective} Love",
            "The {name} Years", "Before {name}", "After {noun}",
            "Letters to {name}", "The {adjective} Heart", "Echoes of {noun}",
            "A Thousand {noun}", "The Burden of {noun}", "{name}'s Choice",
            "The Path to {noun}", "A Single {noun}", "The Weight of {noun}",
            "In the Shadow of {noun}", "The Price of {noun}", "Redemption"
        ],
        "adjectives": ["Broken", "Silent", "Beautiful", "Distant", "Fragile", "Hidden", "Lost", "Timeless"],
        "nouns": ["Souls", "Hearts", "Dreams", "Tears", "Secrets", "Memories", "Choices", "Promises"],
        "verbs": ["Falls", "Waits", "Returns", "Rises", "Fades"],
        "names": ["Sarah", "Michael", "Grace", "David", "Claire", "James"],
        "descriptions": [
            "A powerful story of love and loss spanning decades",
            "Two people discover themselves through unexpected connection",
            "A journey of self-discovery and redemption",
            "Family secrets threaten to tear them apart",
            "A powerful examination of human resilience"
        ],
        "rating_dist": [("PG", 0.2), ("PG-13", 0.4), ("R", 0.4)],
        "length_range": (100, 145),
        "cost_range": (16, 24)
    },
    
    "Horror": {
        "titles": [
            "The {noun} in {location}", "{name} Returns", "The {adjective} {noun}",
            "Curse of the {noun}", "The {noun} Awakens", "Dark {noun}",
            "Nightmare at {location}", "The {adjective} Dead", "Evil {noun}",
            "The {noun} from {location}", "Haunted {noun}", "Possession",
            "The Last {noun}", "Shadows {verb}", "The {adjective} Entity",
            "Something {adjective}", "{noun} Rising"
        ],
        "adjectives": ["Cursed", "Haunted", "Possessed", "Deadly", "Dark", "Evil", "Wicked", "Satanic"],
        "nouns": ["House", "Curse", "Entity", "Demon", "Spirit", "Creature", "Evil", "Darkness"],
        "locations": ["the Asylum", "the Cemetery", "the Mansion", "the Hospital", "the Village"],
        "verbs": ["awakens", "rises", "emerges", "hunts"],
        "names": ["Annabelle", "Exorcism", "Poltergeist"],
        "descriptions": [
            "A group of friends find themselves trapped in a nightmare",
            "An ancient curse is awakened with terrifying consequences",
            "Supernatural forces hunt the inhabitants of an old house",
            "A demonic presence tests the limits of human sanity",
            "Things that should stay buried refuse to rest"
        ],
        "rating_dist": [("PG-13", 0.2), ("R", 0.8)],
        "length_range": (85, 120),
        "cost_range": (15, 22)
    },
    
    "Romance": {
        "titles": [
            "Love in {location}", "{name} and {name2}", "The {adjective} Heart",
            "Eternal {noun}", "A {noun} Romance", "Second {noun}",
            "When Hearts {verb}", "Love After {noun}", "A {adjective} Proposal",
            "Kisses in {location}", "{name}'s Love", "The {adjective} Wedding",
            "A {noun} Story", "Meant to Be", "Against All {noun}",
            "Love Will {verb}", "The {noun} of Life"
        ],
        "adjectives": ["True", "Eternal", "Second", "Perfect", "Sweet", "Tender", "Pure", "Unforgettable"],
        "nouns": ["Love", "Chance", "Dream", "Fate", "Destiny", "Promise", "Hope", "Wishes"],
        "locations": ["Paris", "Rome", "Venice", "Barcelona", "the Beach", "the Mountains"],
        "verbs": ["Meet", "Collide", "Ignite"],
        "names": ["Emma", "Jack", "Sophie", "Marcus", "Grace", "Adam"],
        "names2": ["Lucas", "Nina", "Daniel", "Claire"],
        "descriptions": [
            "Two strangers discover an unexpected connection",
            "A second chance at love when they need it most",
            "Passion ignites between two unlikely souls",
            "Love conquers all obstacles and doubts",
            "A romance that transcends time and circumstance"
        ],
        "rating_dist": [("PG", 0.2), ("PG-13", 0.6), ("R", 0.2)],
        "length_range": (95, 130),
        "cost_range": (14, 22)
    },
    
    "Sci-Fi": {
        "titles": [
            "The Future of {noun}", "{name} Protocol", "Quantum {noun}",
            "The Last {noun}", "Star {name}", "Beyond {location}",
            "The {adjective} Frontier", "Time {verb}", "Android {noun}",
            "The {noun} War", "Cyber {name}", "The {noun} Horizon",
            "Dimension {name}", "Code {noun}", "The {noun} Experiment",
            "Genesis {noun}", "The {adjective} Planet"
        ],
        "adjectives": ["Final", "Unknown", "Last", "Secret", "Hidden", "Infinite", "Parallel", "Alternate"],
        "nouns": ["Protocol", "Wars", "Colonies", "Experiments", "Encounters", "Worlds", "Systems", "Dimensions"],
        "locations": ["Mars", "Venus", "Andromeda", "the Future", "the Past"],
        "verbs": ["Warp", "Jump", "Shift", "Loop"],
        "names": ["Nexus", "Genesis", "Omega", "Alpha", "Phoenix"],
        "descriptions": [
            "Humanity discovers it is not alone in the universe",
            "A mission to save Earth from extinction",
            "Artificial intelligence challenges human supremacy",
            "Time travel creates dangerous paradoxes",
            "Explorers venture into unknown dimensions"
        ],
        "rating_dist": [("PG", 0.1), ("PG-13", 0.6), ("R", 0.3)],
        "length_range": (105, 145),
        "cost_range": (17, 26)
    },
    
    "Animation": {
        "titles": [
            "The Adventures of {name}", "{name}'s Quest", "The {adjective} {noun}",
            "Journey to {location}", "{name} and Friends", "The {noun} Kingdom",
            "Tales of {location}", "The Legend of {name}", "The {adjective} Treasure",
            "Magic in {location}", "The Secret of {noun}", "{name}'s Big Adventure",
            "The {noun} Chronicles", "Legends of {location}", "The {noun} Returns"
        ],
        "adjectives": ["Amazing", "Magical", "Legendary", "Secret", "Hidden", "Lost", "Ancient", "Enchanted"],
        "nouns": ["Dragon", "Kingdom", "Quest", "Adventure", "Mystery", "Treasure", "Heroes", "Champions"],
        "locations": ["Atlantica", "Wonderland", "the Far East", "the Enchanted Forest", "the Mystic Land"],
        "names": ["Zephyr", "Aurora", "Kai", "Luna", "Blaze", "Crystal"],
        "descriptions": [
            "A young hero discovers their magical destiny",
            "Friends embark on an epic adventure",
            "A magical kingdom faces its greatest threat",
            "An outcast finds where they truly belong",
            "Animated adventure with heart and humor"
        ],
        "rating_dist": [("G", 0.6), ("PG", 0.4)],
        "length_range": (80, 120),
        "cost_range": (18, 25)
    },
    
    "Family": {
        "titles": [
            "The {adjective} {noun}", "{name}'s Christmas", "A {noun} Adventure",
            "The {noun} Lesson", "{name} Learns {noun}", "Family {noun}",
            "The Big {noun}", "{name}'s Journey", "A {adjective} Birthday",
            "The {noun} Challenge", "Together {verb}", "The {adjective} Surprise",
            "Our {noun} Story", "The {noun} of Home"
        ],
        "adjectives": ["Wonderful", "Special", "Amazing", "Perfect", "Greatest", "Precious", "Lucky", "Magical"],
        "nouns": ["Adventure", "Christmas", "Vacation", "Holiday", "Birthday", "Lesson", "Journey", "Story"],
        "verbs": ["Forever", "Always", "As One"],
        "names": ["Ollie", "Lily", "Tommy", "Sophie", "Max", "Annie"],
        "descriptions": [
            "A heartwarming tale about family bonds",
            "Children learn valuable lessons through adventure",
            "A holiday story the whole family will enjoy",
            "An adventure that brings a family closer",
            "A feel-good story celebrating togetherness"
        ],
        "rating_dist": [("G", 0.8), ("PG", 0.2)],
        "length_range": (80, 100),
        "cost_range": (14, 20)
    },
    
    "Thriller": {
        "titles": [
            "The {noun} Conspiracy", "Edge of {noun}", "The {adjective} Target",
            "{name} Protocol", "Silent {noun}", "The {noun} Game",
            "Deception {name}", "The {adjective} Hunt", "Lethal {noun}",
            "The {noun} Threat", "Hidden Agenda", "The {noun} Lies",
            "Zero {noun}", "The {adjective} Truth"
        ],
        "adjectives": ["Deadly", "Fatal", "Dangerous", "Hidden", "Secret", "Dark", "Twisted", "Shocking"],
        "nouns": ["Conspiracy", "Lies", "Truth", "Deception", "Threat", "Game", "Code", "Evidence"],
        "names": ["Nexus", "Cipher", "Black", "Shadow", "Eclipse"],
        "descriptions": [
            "A detective races against time to stop a killer",
            "Nothing is what it seems in this twisted tale",
            "A conspiracy threatens to destroy everything",
            "One woman must uncover a dangerous truth",
            "Suspense and betrayal at every turn"
        ],
        "rating_dist": [("PG-13", 0.3), ("R", 0.7)],
        "length_range": (95, 130),
        "cost_range": (15, 23)
    }
}


def generate_film_title(category: str) -> Tuple[str, str, str]:
    """
    Generate a realistic film title, description, and rating based on category
    Returns: (title, description, rating)
    """
    import random
    
    if category not in FILM_TEMPLATES:
        category = "Drama"
    
    template = FILM_TEMPLATES[category]
    
    # Choose a title template
    title_template = random.choice(template["titles"])
    
    # Build the title by replacing placeholders
    title = title_template
    
    if "{adjective}" in title:
        title = title.replace("{adjective}", random.choice(template["adjectives"]))
    if "{noun}" in title:
        title = title.replace("{noun}", random.choice(template["nouns"]))
    if "{location}" in title:
        title = title.replace("{location}", random.choice(template["locations"]))
    if "{verb}" in title:
        title = title.replace("{verb}", random.choice(template["verbs"]))
    if "{name}" in title and "name2" not in template:
        title = title.replace("{name}", random.choice(template.get("names", ["Unknown"])))
    if "{name}" in title and "{name2}" in template:
        title = title.replace("{name}", random.choice(template.get("names", ["Unknown"])))
    if "{name2}" in title:
        title = title.replace("{name2}", random.choice(template.get("names2", ["Unknown"])))
    
    # Choose description
    description = random.choice(template["descriptions"])
    
    # Choose rating
    rating_choices = template["rating_dist"]
    rating = random.choices([r[0] for r in rating_choices], weights=[r[1] for r in rating_choices])[0]
    
    return title, description, rating


# Import the new film generator
from film_generator import FilmGenerator

def add_film_batch(mysql_config: dict, num_films: int, category_focus: str = None, description: str = "", sim_date: date = None) -> int:
    """Add new films to the database with inventory copies using the new film generator"""
    try:
        film_generator = FilmGenerator(mysql_config)
        film_generator.connect()
        
        # Create film_releases table if it doesn't exist
        film_generator.create_film_releases_table()
        
        # Generate films using the new film generator
        films_added = film_generator.add_film_batch(
            num_films, category_focus, description, sim_date
        )
        
        film_generator.disconnect()
        return films_added
        
    except Exception as e:
        logger.error(f"Failed to add films: {e}")
        return 0


def get_film_releases_for_week(week_num: int) -> Tuple[bool, int, str, str]:
    """Check if there's a film release scheduled for this week"""
    for week, num_films, category_focus, desc in SimulationConfig.FILM_RELEASES:
        if week == week_num:
            return True, num_films, category_focus, desc
    return False, 0, None, ""


def add_incremental_weeks(mysql_config: dict, num_weeks: int, seasonal_drift: float = 0.0, current_sim_week: int = 0, total_weeks: int = 0) -> int:
    """
    Add incremental weeks of transactions
    Returns: number of weeks added
    """
    try:
        from generator import DVDRentalDataGenerator
        
        generator = DVDRentalDataGenerator(mysql_config)
        generator.seasonal_drift = seasonal_drift
        generator.connect()
        
        # Get current database status
        generator.cursor.execute("SELECT MAX(rental_date) FROM rental")
        last_rental_row = generator.cursor.fetchone()
        
        if not last_rental_row or not last_rental_row[0]:
            logger.warning("No existing rentals found")
            generator.disconnect()
            return 0
        
        last_rental = last_rental_row[0]
        
        # Calculate next week start
        if isinstance(last_rental, str):
            last_rental = datetime.strptime(last_rental, '%Y-%m-%d %H:%M:%S')
        
        last_date = last_rental.date() if hasattr(last_rental, 'date') else last_rental
        next_week_start = last_date + timedelta(days=1)
        next_week_start = next_week_start - timedelta(days=next_week_start.weekday())
        
        # Get week count
        generator.cursor.execute("SELECT MIN(rental_date) FROM rental")
        min_rental = generator.cursor.fetchone()[0]
        start_date = min_rental.date() if hasattr(min_rental, 'date') else min_rental
        weeks_since_start = (next_week_start - start_date).days // 7
        
        # Add weeks
        weeks_added = 0
        for i in range(num_weeks):
            week_start = next_week_start + timedelta(weeks=i)
            week_number = weeks_since_start + i + 1
            generator.add_week_of_transactions(week_start, week_number)
            weeks_added += 1
            
            # Report progress for this week if we have total weeks info
            if total_weeks > 0:
                overall_progress = (current_sim_week + weeks_added) / total_weeks * 100
                logger.info(f"   Week {current_sim_week + weeks_added} completed ({overall_progress:.1f}% overall)")
        
        generator.disconnect()
        return weeks_added
        
    except Exception as e:
        logger.error(f"Failed to add incremental weeks: {e}")
        raise


def get_inventory_additions_for_week(week_num: int) -> Tuple[bool, int, str]:
    """Check if inventory should be added this week"""
    try:
        from inventory_scheduler import get_inventory_additions_for_week as scheduler_get_inventory
        return scheduler_get_inventory(week_num, SimulationConfig.TOTAL_WEEKS, SimulationConfig.START_DATE)
    except Exception as e:
        logger.warning(f"Failed to get inventory additions from scheduler: {e}")
        return False, 0, ""


def display_simulation_plan():
    """Display the simulation plan"""
    logger.info("=" * 80)
    logger.info("SIMULATION PLAN")
    logger.info("=" * 80)
    logger.info(f"Start Date: {SimulationConfig.START_DATE}")
    logger.info(f"Duration: {SimulationConfig.TOTAL_WEEKS} weeks (~{SimulationConfig.TOTAL_WEEKS / 52:.1f} years)")
    end_date = SimulationConfig.START_DATE + timedelta(weeks=SimulationConfig.TOTAL_WEEKS)
    logger.info(f"End Date: {end_date}")
    
    logger.info(f"\nInventory Additions Schedule:")
    try:
        from inventory_scheduler import generate_seasonal_trends
        inventory_schedule = generate_seasonal_trends(SimulationConfig.TOTAL_WEEKS, SimulationConfig.START_DATE)
        for week, qty, desc in inventory_schedule:
            date = SimulationConfig.START_DATE + timedelta(weeks=week)
            logger.info(f"  Week {week:3d} ({date}): +{qty:3d} items - {desc}")
    except Exception as e:
        logger.warning(f"Failed to generate inventory schedule: {e}")
        logger.info("  Using default schedule...")
        # Fallback to a simple schedule
        logger.info(f"  Week {0:3d} ({SimulationConfig.START_DATE}): +{0:3d} items - Initial inventory created by generator")
    
    logger.info(f"\nFilm Releases Schedule:")
    for week, num_films, category, desc in SimulationConfig.FILM_RELEASES:
        date = SimulationConfig.START_DATE + timedelta(weeks=week)
        logger.info(f"  Week {week:3d} ({date}): +{num_films:d} films ({category or 'Mixed'}) - {desc}")
    
    logger.info("=" * 80 + "\n")


def main():
    """Main simulation orchestration"""
    print("\n")
    logger.info("‚ïî" + "‚ïê" * 78 + "‚ïó")
    logger.info("‚ïë" + " MASTER DVD RENTAL SIMULATION ".center(78) + "‚ïë")
    logger.info("‚ïö" + "‚ïê" * 78 + "‚ïù")
    
    # Parse command-line arguments
    override_database = None
    if len(sys.argv) > 1:
        if sys.argv[1] == '--database' and len(sys.argv) > 2:
            override_database = sys.argv[2]
            logger.info(f"Database override: {override_database}")
        elif sys.argv[1] != '--database':
            override_database = sys.argv[1]
            logger.info(f"Database override: {override_database}")
    
    config = load_config(override_database=override_database)
    mysql_config = config['mysql']
    
    # Load master simulation configuration
    master_config = config.get('master_simulation', {})
    SimulationConfig.TOTAL_WEEKS = master_config.get('total_weeks', 156)
    start_date_str = master_config.get('start_date', '2001-10-01')
    SimulationConfig.START_DATE = datetime.strptime(start_date_str, '%Y-%m-%d').date()
    
    # Create database if it doesn't exist (required for CLI overrides)
    if not create_database_if_needed(mysql_config):
        logger.error("Failed to create database. Exiting.")
        sys.exit(1)
    
    display_simulation_plan()
    
    try:
        # PHASE 1: Initial setup
        logger.info(f"Start date set to {SimulationConfig.START_DATE}")
        input("\nPress Enter to begin simulation...")
        
        initial_weeks, initial_inventory = run_initial_setup(mysql_config)
        current_week = initial_weeks
        
        # PHASE 2: Incremental updates with seasonal variations
        logger.info("\n" + "=" * 80)
        logger.info("PHASE 2: Incremental Weekly Updates with Seasonal Variations")
        logger.info("=" * 80)
        
        remaining_weeks = SimulationConfig.TOTAL_WEEKS - current_week
        logger.info(f"Adding {remaining_weeks} weeks of transactions...\n")
        
        batch_size = 4  # Add 4 weeks at a time for efficiency
        weeks_added = 0
        total_inventory_added = 0
        
        while weeks_added < remaining_weeks:
            # Check for film releases
            current_sim_week = current_week + weeks_added
            has_films, num_films, category, film_desc = get_film_releases_for_week(current_sim_week)
            
            if has_films and num_films > 0:
                current_date = SimulationConfig.START_DATE + timedelta(weeks=current_sim_week)
                logger.info(f"\nüé¨ Week {current_sim_week} ({current_date}): {film_desc}")
                add_film_batch(mysql_config, num_films, category, film_desc, sim_date=current_date)
            
            # Check for inventory additions
            should_add, qty, desc = get_inventory_additions_for_week(current_sim_week)
            
            if should_add and qty > 0:
                current_date = SimulationConfig.START_DATE + timedelta(weeks=current_sim_week)
                # Get Monday of the current active rental simulation week
                monday_of_rental_week = get_monday_of_latest_rental_week(mysql_config)
                logger.info(f"\nüì¶ Week {current_sim_week} ({current_date}): {desc}")
                added = add_inventory_batch(mysql_config, qty, desc, date_purchased=monday_of_rental_week)
                total_inventory_added += added
            
            # Calculate weeks to add
            weeks_to_add = min(batch_size, remaining_weeks - weeks_added)
            
            # Get seasonal drift for the middle of this batch
            batch_middle_week = current_sim_week + weeks_to_add // 2
            batch_middle_date = SimulationConfig.START_DATE + timedelta(weeks=batch_middle_week)
            seasonal_drift = get_seasonal_drift(batch_middle_date)
            
            # Add weeks
            current_date = SimulationConfig.START_DATE + timedelta(weeks=current_sim_week)
            logger.info(f"\nüìä Weeks {current_sim_week}-{current_sim_week + weeks_to_add - 1} "
                       f"({current_date.strftime('%b %d, %Y')} - ...)")
            logger.info(f"   Seasonal drift: {seasonal_drift:+.0f}% "
                       f"(month: {batch_middle_date.strftime('%B')})")
            
            added_weeks = add_incremental_weeks(mysql_config, weeks_to_add, seasonal_drift, current_sim_week, SimulationConfig.TOTAL_WEEKS)
            weeks_added += added_weeks
            
            progress = (weeks_added / remaining_weeks) * 100
            logger.info(f"   Progress: {progress:.1f}% ({weeks_added}/{remaining_weeks} weeks)")
        
        # PHASE 3: Summary
        logger.info("\n" + "=" * 80)
        logger.info("PHASE 3: Simulation Complete - Database Summary")
        logger.info("=" * 80)
        
        conn = mysql.connector.connect(
            host=mysql_config['host'],
            user=mysql_config['user'],
            password=mysql_config['password'],
            database=mysql_config['database']
        )
        cursor = conn.cursor()
        
        # Get statistics
        cursor.execute("SELECT COUNT(*) FROM rental")
        total_rentals = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(DISTINCT customer_id) FROM customer WHERE activebool = TRUE")
        active_customers = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM inventory")
        total_inventory = cursor.fetchone()[0]
        
        cursor.execute("SELECT MIN(rental_date), MAX(rental_date) FROM rental")
        date_range = cursor.fetchone()
        min_date, max_date = date_range
        
        cursor.execute("""
            SELECT COUNT(*) FROM rental 
            WHERE return_date IS NULL
        """)
        checked_out = cursor.fetchone()[0]
        
        # Calculate inventory growth
        inventory_growth = ((total_inventory - initial_inventory) / initial_inventory) * 100 if initial_inventory > 0 else 0
        
        cursor.close()
        conn.close()
        
        logger.info(f"\n‚úì Total Rentals: {total_rentals:,}")
        logger.info(f"‚úì Active Customers: {active_customers:,}")
        logger.info(f"‚úì Total Inventory Items: {total_inventory:,} "
                   f"(+{total_inventory_added:,} added during simulation)")
        logger.info(f"‚úì Inventory Growth: {inventory_growth:.1f}% (from {initial_inventory:,} to {total_inventory:,})")
        logger.info(f"‚úì Data Range: {min_date} to {max_date}")
        logger.info(f"‚úì Currently Checked Out: {checked_out:,} items")
        logger.info(f"‚úì Average Rentals per Week: {total_rentals // SimulationConfig.TOTAL_WEEKS:,}")
        
        logger.info("\n" + "=" * 80)
        logger.info("SIMULATION SUCCESSFUL!")
        logger.info("=" * 80)
        logger.info(f"\nDatabase '{mysql_config['database']}' is ready with {SimulationConfig.TOTAL_WEEKS // 52:.1f} years of realistic transaction data.")
        logger.info("\nTo extend simulation to 10 years:")
        logger.info("  1. Set TOTAL_WEEKS = 520 in SimulationConfig")
        logger.info("  2. Add more entries to INVENTORY_ADDITIONS (extend the pattern)")
        logger.info(f"  3. Run: python master_simulation.py {mysql_config['database']}")
        logger.info("\n")
        
    except Exception as e:
        logger.error(f"\n‚ùå Simulation failed: {e}")
        logger.error("Make sure MySQL is running and config.json is set up correctly")
        sys.exit(1)


if __name__ == '__main__':
    main()